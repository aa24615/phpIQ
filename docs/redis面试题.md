### 常用的数据类型有哪些
字符串String
列表List
集合Set
有序集合Zset
哈希Hash



### 数据过期策略
Redis 的过期策略就是指当 Redis 中缓存的 Key 过期了，Redis 如何处理

- 定时过期：每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好

- 惰性过期：访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好

- 定期过期：隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果


### 内存淘汰机制

- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

### 事务机制
Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
Redis事务的主要作用就是串联多个命令防止别的命令插队。
不保证原子性
### 缓存击穿
缓存击穿是指，针对某个热点数据，突然在缓存中失效，然后这些请求到热点数据的请求会都请求到数据库。

缓存击穿一般是热点 key 在 Redis 中过期了导致的。 最直接的方法就是，对于热点 key ，就不设置过期时间。
### 缓存穿透
缓存穿透指的是，数据既不在 Redis 中，也不在数据库中。每次请求 Redis 发现没有对应的 key之后，再去请求数据库，发现数据库也没有。 那么这时， Redis 就相当于一个摆设，没有具体的作用了。如果有人恶意攻击系统，故意使用空值或者其他不存在的值进行频繁请求，那么也会对数据库造成比较大的压力。
为了避免缓存穿透，我们可以：
1、缓存空值或缺省值
2、采用布隆过滤器，提前判断是否有此数据。

### 缓存雪崩

什么是缓存雪崩？

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。    
和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

缓存雪崩解决方案

常用的解决方案有：

均匀过期加互斥锁缓存永不过期双层缓存策略

 - 均匀过期

设置不同的过期时间，让缓存失效的时间点尽量均匀。
通常可以为有效期增加随机值或者统一规划有效期。

- 加互斥锁

跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。

- 缓存永不过期

跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。

- 双层缓存策略
使用主备两层缓存： 
主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。   
备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。

### 分布式锁
php应用分布式锁，用lua脚本编写执行

### 集群
Hash和Set类型应用的区别
Hash存储的是一组hash信息，类似java中的HashMap，可以存储Object信息。
Set存储的是一个经过去重的无序集合，SMEMBERS获取所有数据，多个set可用命令行做集合处理（交集SINTER，并集SUNION，差集SDIFF）
SORTEDSET（ZSET）是一个经过去重的有序的集合。有序集合的应用场景为按照指定权重(score分值)对内容进行排序，相比于set多一个score字段，可以进行增加减少操作，ZINCRBY命令进行score的增减指定值
### 持久化
https://blog.csdn.net/m0_43424329/article/details/124364120
RDB：子进程定时将数据写到临时文件，然后将临时文件替换上次持久化后的文件。最后一次持久化后的数据可能丢失，分为自动触发和手动触发两种方式
数据恢复：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。
### ~~rdb优点和缺点~~
优点
1.RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。
2.生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。
3.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
缺点
1.RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，如果不采用压缩算法(主进程 fork 出子进程，其实是共享一份真实的内存空间，但是为了能在记录快照的时候，也能让主线程处理写操作，采用的是 Copy-On-Write（写时复制）技术，只有需要修改的内存才会复制一份出来，所以内存膨胀到底有多大，看修改的比例有多大)，频繁执行成本过高(影响性能)
2.RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容)
3.在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)
AOF：用日志记录每个写操作，将Redis所有的写操作记录下来，只追加不修改文件。redis启动后会读取文件重新构建数据。
AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）
### AOF优点和缺点
- 优点
1.备份机制更稳健，丢失数据概率更低。
2.可读的日志文本，通过操作AOF稳健，可以处理误操作。
- 缺点
1.比起RDB占用更多的磁盘空间。
2.恢复备份速度要慢。
3.每次读写都同步的话，有一定的性能压力。
4.存在个别Bug，造成恢复不能。
- 总结
官方推荐两个都启用
如果对数据不敏感，可以选单独用RDB；
不建议单独用 AOF，因为可能会出现Bug；
如果只是做纯内存缓存，可以都不用。
  
### redis字符串类型底层实现
redis的String类型在底层实现中有三种实现方式。
- 使用整数值实现的字符串对象，使用的是8个字节的long类型进行存储。
- 使用embstr编码的动态字符串实现的字符串对象，embeded string嵌入式字符串，存储长度小于44字节的字符串
- 动态字符串实现的字符串对象，raw原始字符串，存储长度大于44字节的字符串。
  redis会根据值的类型和长度自动选择存储的类型。
  动态字符串是redis写的一个抽象数据类型，存储了字符串的长度、空闲长度和字符数组等字段。
  Redis主从同步实现方式
  主节点定时发送RDB文件给从节点，还有写命令及偏移量到缓冲区，从节点根据写命令和偏移量进行同步
  
### 保证Redis缓存和数据库数据的一致性

保证Redis缓存和数据库数据的一致性是一个重要的问题，特别是在高并发环境下。以下是一些常用的策略和方法来确保两者之间的数据一致性：

- 双写策略：

当数据在数据库中更新后，立即更新Redis缓存。      
这种策略可能会遇到竞态条件，特别是在高并发场景下。

- 失效策略：

当数据在数据库中更新后，不直接更新Redis缓存，而是删除该缓存项。      
当下一次请求需要这个数据时，它会从数据库中读取最新数据并放入Redis缓存。      
这种策略避免了直接更新缓存时的竞态条件，但可能会增加数据库的读取压力。

- 延时双删策略：

更新数据库后，先删除缓存。     
等待一段时间（例如几百毫秒），再次删除缓存。      
这样可以确保在缓存失效期间，即使有新的请求进入，也会从数据库中读取最新数据并放入缓存。

- 使用消息队列：

当数据库中的数据更新时，将更新操作放入消息队列。      
有一个单独的进程或线程从消息队列中读取更新操作，并更新Redis缓存。     
这种策略可以确保数据库和缓存的更新操作是异步的，从而减少了延迟。

- 使用分布式锁：

当需要更新数据库和缓存时，先获取分布式锁。   
成功获取锁后，更新数据库和缓存。    
释放锁。    
这种策略可以确保在更新数据库和缓存时，只有一个操作能够成功。

- 监控和告警：

监控Redis缓存和数据库的数据一致性。    
如果发现数据不一致，立即触发告警，并尽快修复问题。

- 避免复杂查询：

尽量将复杂的查询逻辑放在数据库中，而不是在Redis缓存中进行。    
这样可以减少因缓存和数据库数据不一致而引发的错误。

- 考虑数据的时效性：

对于一些时效性较强的数据，可以考虑不放入Redis缓存，或者设置较短的缓存过期时间。    

需要注意的是，每种策略都有其优缺点，需要根据具体的应用场景和需求来选择最合适的策略。同时，确保Redis缓存和数据库数据的一致性是一个复杂的问题，需要综合考虑多个因素，并进行充分的测试和验证。