### 常用的数据类型有哪些
字符串String
列表List
集合Set
有序集合Zset
哈希Hash

### 常用命令有哪些

一、基础命令

  - ping（心跳命令）
  - get/set（读写键值命令）
  - select（切换数据库）
  - dbsize（查看key数量）
  - flushdb（删除当前库中所有数据）
  - flushall（删除所有DB中的数据）

二、Key 相关操作命令
  - keys（查找key）
  - exists（检查key是否存在）
  - del（删除key）
  - rename（重命名）
  - move（移动key）
  - type（key类型）
  - expire/pexpire（过期时间）
  - ttl/pttl（获取剩余时间）
  - persist（移除过期时间）
  - randomkey（返回一个不删除的key）
  - scan（用于迭代数据库中的数据库键）

三、String型Value操作命令
  - set（添加一个key）
  - setex/psetex (添加一个key并设置过期时间)
  - setnx (不存在则设置,存在不做任何操作并返回1)
  - getset (将给定 key 的值设为 value ，并返回 key 的旧值)
  - mset/msetnx (同时设置一个或多个 key-value 对)
  - mget (返回所有(一个或多个)给定 key 的值)
  - append (追加到 key 原来的值的末尾)
  - incr/decr (自动递增一/自动递减一)
  - incrby/decrby (将 key 中存储的数字值增加/减少指定的数值，这个数值只能是整数，可以是负数，但不能是小数)
  - incrbyfloat (为 key 中所储存的值加上浮点数增量 increment )
  - strlen (返回 key 所储存的字符串值的长度)
  - getrange (返回 key 中字符串值的子字符串)
  - setrange (用 value 参数替换给定 key 所储存的字符串值 str，从偏移量 offset 开始)
四、Hash型Value操作命令
  - hset (将哈希表 key 中的域 field 的值设为 value)
  - hget (返回哈希表 key 中给定域 field 的值)
  - hmset (同时将多个 field-value (域-值)对设置到哈希表 key 中)
  - hmget (按照给出顺序返回哈希表 key 中一个或多个域的值)
  - hgetall (返回哈希表 key 中所有的域和值)
  - hsetnx (将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在)
  - hdel (删除哈希表)
  - hexists (查看哈希表 key 中给定域 field 是否存在)
  - hincrby/hincrbyfloat (为哈希表 key 中的域 field 的值加上增量 increment 。)
  - hkeys/hvals (返回哈希表 key 中的所有域/值)
  - hlen (返回哈希表 key 中域的数量)
  - hstrlen (返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）)

五、List型Value操作命令

  - lpush/rpush (将一个或多个值 value 插入到列表 key 的表头/表尾)
  - llen (返回列表 key 的长度)
  - lindex (返回列表 key 中，下标为 index 的元素。列表从 0 开始计数)
  - lset (将列表 key 下标为 index 的元素的值设置为 value )
  - lrange (返回列表 key 中指定区间[start, stop]内的元素，即包含两个端点)
  - lpushx/rpushx (将值 value 插入到列表 key 的表头/表尾，当且仅当 key 存在并且是一个列表)
  - linsert (将值 value 插入到列表 key 当中，位于元素 pivot 之前或之后)
  - lpop/rpop (从列表 key 的表头/表尾移除 count 个元素，并返回移除的元素。count 默认值 1)
  - blpop/brpop (BLPOP/BRPOP 是列表的阻塞式(blocking)弹出命令)
  - rpoplpush (命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作)
  - brpoplpush (BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本)
  - lrem (根据参数 count 的值，移除列表中与参数 value 相等的元素)
  - ltrim (对一个列表进行修剪(trim))

六、Set型Value操作命令

  - sadd (将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略)
  - smembers (返回集合 key 中的所有成员)
  - scard (返回 Set 集合的长度)
  - sismember (判断 member 元素是否集合 key 的成员)
  - smove (将 member 元素从 source 集合移动到 destination 集合)
  - srem (移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略，且返回成功移除的元素个数)
  - srandmember (返回集合中的 count 个随机元素。count 默认值为 1)
  - spop (移除并返回集合中的 count 个随机元素。count 必须为正数，且默认值为 1)
  - sdiff/sdiffstore (返回第一个集合与其它集合之间的差集。差集，difference)
  - sinter / sinterstore (返回多个集合间的交集。交集，intersection)
  - sunion/sunionstore (返回多个集合间的并集。并集，union)
  
七、有序Set型Value操作命令

  - zadd (将一个或多个 member 元素及其 score 值加入到有序集 key 中的适当位置)
  - zrange/zrevrange (返回有序集 key 中，指定区间内的成员)
  - zrangebyscore/zrevrangebyscore (返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员)
  - zcard (返回集合的长度)
  - zcount (返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min或 max )的成员的数量)
  - zscore (返回有序集 key 中，成员 member 的 score 值)
  - zincrby (为有序集 key 的成员 member 的 score 值加上增量 increment )
  - zrank/zrevrank (返回有序集 key 中成员 member 的排名)
  - zrem (移除有序集 key 中的一个或多个成员，不存在的成员将被忽略)
  - zremrangebyrank (移除有序集 key 中，指定排名(rank)区间内的所有成员)
  - zremrangebyscore (移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或max )的成员)
  - zrangebylex (该命令仅适用于集合中所有成员都具有相同分值的情况)
  - zlexcount (该命令仅适用于集合中所有成员都具有相同分值的情况)
  - zremrangebylex (该命令仅适用于集合中所有成员都具有相同分值的情况)


### 数据类型的应用场景

#### 字符串类型


- **数据缓存：**       
  
  Redis 作为数据缓存层，MySQL 作为数据存储层。    
  应用服务器首先从 Redis 中获取数据，如果缓存层中没有，则从MySQL 中获取后先存入缓存层再返回给应用服务器。

- **计数器：**       
  
  在 Redis 中写入一个 value 为数值型的 key 作为平台计数器、视频播放计数器等。       
  每个有效客户端访问一次，或视频每播放一次，都是直接修改 Redis 中的计数器，      
  然后再以异步方式持久化到其它数据源中，例如持久化到 MySQL。

- **共享Session：**    
  
  对于一个分布式应用系统，如果将类似用户登录信息这样的 Session 数据保存在提供登录服务的服务器中，      
  那么如果用户再次提交像收藏、支付等请求时可能会出现问题：    
  在提供收藏、支付等服务的服务器中并没有该用户的 Session 数据，从而导致该用户需要重新登录。     
  对于用户来说，这是不能接受的。   
  此时，可以将系统中所有用户的 Session 数据全部保存到 Redis 中，   
  用户在提交新的请求后，系统先从Redis 中查找相应的Session 数据，如果存在，则再进行相关操作，否则跳转到登录页面。      
  这样就不会引发“重新登录”问题。
  
- **限速器：**    
  
  现在很多平台为了防止 DoS（Denial of Service，拒绝服务）攻击，一般都会限制一个 IP不能在一秒内访问超过 n 次。     
  而 Redis 可以可以结合 key 的过期时间与 incr 命令来完成限速功能，充当限速器。     
  注意，其无法防止 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击。
  
- **分布式锁：**   
  
  setnx key value，当key不存在时，将key 的值设为 value ，返回1;
  若给定的 key 已经存在，则setnx不做任何动作，返回0。     
  当setnx返回1时，表示获取锁，做完操作以后del key，表示释放锁；       
  如果setnx返回0表示获取锁失败，可以通过以上的思路来实现分布式锁的机制。    
  



####  哈希类型


- **对象属性存储**    

  key 为对象名称，value 为描述对象属性的 Map，对对象属性的修改在Redis 中就可直接完成。      
  其不像String 型 Value 存储对象，那个对象是序列化过的，    
  例如序列化为 JSON 串，对对象属性值的修改需要先反序列化为对象后再修改，修改后再序列化为JSON 串后写入到 Redis。
  


#### 列表类型

- **栈**

  通过 lpush + lpop 可以实现栈数据结构效果：先进后出。     
  通过 lpush 从列表左侧插入数据，通过 lpop 从列表左侧取出数据。     
  当然，通过 rpush + rpop 也可以实现相同效果，只不过操作的是列表右侧。

- **队列**

  通过 lpush + rpop 可以实现队列数据结构效果：先进先出。      
  通过 lpush 从列表左侧插入数据，通过 rpop 从列表右侧取出数据。     
  当然，通过 rpush + lpop 也可以实现相同效果，只不过操作的方向正好相反。

- **阻塞式消息队列**
  
  通过 lpush + brpop 可以实现阻塞式消息队列效果。     
  作为消息生产者的客户端使用 lpush从列表左侧插入数据，   
  作为消息消费者的多个客户端使用 brpop 阻塞式“抢占”列表尾部数据进行消费，      
  保证了消费的负载均衡与高可用性。brpop 的 timeout 设置为 0，表示只要没有数据可弹出，就永久阻塞。

- **动态有限集合**
  
  通过 lpush + ltrim 可以实现有限集合。      
  通过lpush 从列表左侧向列表中添加数据，通过 ltrim 保持集合的动态有限性。    
  像企业的末位淘汰、学校的重点班等动态管理，都可通过这种动态有限集合来实现。     
  当然，通过rpush + ltrim 也可以实现相同效果，只不过操作的方向正好相反。

#### 集合类型

- **动态黑名单**
  
  例如某服务器中要设置用于访问控制的黑名单。   
  如果直接将黑名单写入服务器的配置文件，那么存在的问题是，无法动态修改黑名单。      
  此时可以将黑名单直接写入Redis，只要有客户端来访问服务器，   
  服务器在获取到客户端IP 后先从Redis 的黑名单中查看是否存在该IP，如果存在，则拒绝访问，否则访问通过。   

- **有限随机数**
  
  有限随机数是指返回的随机数是基于某一集合范围内的随机数，例如抽奖、随机选人。    
  通过 spop 或 srandmember 可以实现从指定集合中随机选出元素。     

- **用户画像**
  
  社交平台、电商平台等各种需要用户注册登录的平台，会根据用户提供的资料与用户使用习惯，      
  为每个用户进行画像，即为每个用户定义很多可以反映该用户特征的标签，     
  这些标签就可以使用sadd 添加到该用户对应的集合中。这些标签具有无序、不重复特征。

  同时平台还可以使用 sinter/sinterstore 根据用户画像间的交集进行好友推荐、商品推荐、客户推荐等。


#### 有序集合


- **排行榜：**    
  可以将用户的分数作为有序集合的分数，使用有序集合的排序特性来实现排行榜功能。
- **实时热门数据统计：**   
  可以将数据的热度、点击量等作为有序集合的分数，通过不断更新分数来实时统计热门数据。
- **带权重的任务调度：**   
  可以将任务的执行时间戳作为有序集合的分数，使用有序集合的排序特性来实现带权重的任务调度。
- **社交网络：**   
  可以将用户之间的关系强度作为有序集合的分数，使用有序集合的排序特性来实现好友推荐、共同好友等功能。
- **数据过期策略：**   
  可以将数据的过期时间作为有序集合的分数，使用有序集合的排序特性来实现根据过期时间自动清理数据。


### 数据过期策略


Redis 的过期策略就是指当 Redis 中缓存的 Key 过期了，Redis 如何处理

- **定时过期：**
  
  每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好

- **惰性过期：**
  
  访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好

- **定期过期：**
  
  隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果




### 内存淘汰机制

- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

### 事务机制

Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
Redis事务的主要作用就是串联多个命令防止别的命令插队。
不保证原子性


### 缓存穿透
缓存穿透指的是，数据既不在 Redis 中，也不在数据库中。      
每次请求 Redis 发现没有对应的 key之后，再去请求数据库，发现数据库也没有。    
那么这时， Redis 就相当于一个摆设，没有具体的作用了。    
如果有人恶意攻击系统，故意使用空值或者其他不存在的值进行频繁请求，那么也会对数据库造成比较大的压力。    
为了避免缓存穿透，我们可以：

- 缓存空值或缺省值 (设置短暂的过期时间)
- 采用布隆过滤器，提前判断是否有此数据。


### 缓存击穿

缓存击穿是指，针对某个热点数据，突然在缓存中失效，然后这些请求到热点数据的请求会都请求到数据库。    
缓存击穿一般是热点 key 在 Redis 中过期了导致的。

- 互斥锁 (强一致,性能差)   
  当key过期后,加锁并去数据库中查询并更新缓存
  
- 逻辑过期 (高可用,性能忧)    
  设置key永不过期,在数据中保存一个生效时间,当过期后通过异步更新缓存
  



### 缓存雪崩

什么是缓存雪崩？

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。    
和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

缓存雪崩解决方案

常用的解决方案有：

均匀过期加互斥锁缓存永不过期双层缓存策略

 - 均匀过期

设置不同的过期时间，让缓存失效的时间点尽量均匀。
通常可以为有效期增加随机值或者统一规划有效期。

- 加互斥锁

跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。

- 逻辑过期

跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。

- 双层缓存策略

使用主备两层缓存： 
主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。   
备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。


- 集群

如果是redis服务宕机导致,可以使用redis集群,从主,哨兵来提高服务的可用性

### 分布式锁
php应用分布式锁，用lua脚本编写执行

### 集群
Hash和Set类型应用的区别
Hash存储的是一组hash信息，类似java中的HashMap，可以存储Object信息。
Set存储的是一个经过去重的无序集合，SMEMBERS获取所有数据，多个set可用命令行做集合处理（交集SINTER，并集SUNION，差集SDIFF）
SORTEDSET（ZSET）是一个经过去重的有序的集合。有序集合的应用场景为按照指定权重(score分值)对内容进行排序，相比于set多一个score字段，可以进行增加减少操作，ZINCRBY命令进行score的增减指定值
### 持久化
https://blog.csdn.net/m0_43424329/article/details/124364120
RDB：子进程定时将数据写到临时文件，然后将临时文件替换上次持久化后的文件。最后一次持久化后的数据可能丢失，分为自动触发和手动触发两种方式
数据恢复：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。
### ~~rdb优点和缺点~~
优点
1.RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。
2.生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。
3.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
缺点
1.RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，如果不采用压缩算法(主进程 fork 出子进程，其实是共享一份真实的内存空间，但是为了能在记录快照的时候，也能让主线程处理写操作，采用的是 Copy-On-Write（写时复制）技术，只有需要修改的内存才会复制一份出来，所以内存膨胀到底有多大，看修改的比例有多大)，频繁执行成本过高(影响性能)
2.RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容)
3.在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)
AOF：用日志记录每个写操作，将Redis所有的写操作记录下来，只追加不修改文件。redis启动后会读取文件重新构建数据。
AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）
### AOF优点和缺点
- 优点
1.备份机制更稳健，丢失数据概率更低。
2.可读的日志文本，通过操作AOF稳健，可以处理误操作。
- 缺点
1.比起RDB占用更多的磁盘空间。
2.恢复备份速度要慢。
3.每次读写都同步的话，有一定的性能压力。
4.存在个别Bug，造成恢复不能。
- 总结
官方推荐两个都启用
如果对数据不敏感，可以选单独用RDB；
不建议单独用 AOF，因为可能会出现Bug；
如果只是做纯内存缓存，可以都不用。
  
### redis字符串类型底层实现
redis的String类型在底层实现中有三种实现方式。
- 使用整数值实现的字符串对象，使用的是8个字节的long类型进行存储。
- 使用embstr编码的动态字符串实现的字符串对象，embeded string嵌入式字符串，存储长度小于44字节的字符串
- 动态字符串实现的字符串对象，raw原始字符串，存储长度大于44字节的字符串。
  redis会根据值的类型和长度自动选择存储的类型。
  动态字符串是redis写的一个抽象数据类型，存储了字符串的长度、空闲长度和字符数组等字段。
  Redis主从同步实现方式
  主节点定时发送RDB文件给从节点，还有写命令及偏移量到缓冲区，从节点根据写命令和偏移量进行同步
  
### 保证Redis缓存和数据库数据的一致性

保证Redis缓存和数据库数据的一致性是一个重要的问题，特别是在高并发环境下。以下是一些常用的策略和方法来确保两者之间的数据一致性：

- 双写策略：

当数据在数据库中更新后，立即更新Redis缓存。      
这种策略可能会遇到竞态条件，特别是在高并发场景下。

- 失效策略：

当数据在数据库中更新后，不直接更新Redis缓存，而是删除该缓存项。      
当下一次请求需要这个数据时，它会从数据库中读取最新数据并放入Redis缓存。      
这种策略避免了直接更新缓存时的竞态条件，但可能会增加数据库的读取压力。

- 延时双删策略：

更新数据库后，先删除缓存。     
等待一段时间（例如几百毫秒），再次删除缓存。      
这样可以确保在缓存失效期间，即使有新的请求进入，也会从数据库中读取最新数据并放入缓存。

- 使用消息队列：

当数据库中的数据更新时，将更新操作放入消息队列。      
有一个单独的进程或线程从消息队列中读取更新操作，并更新Redis缓存。     
这种策略可以确保数据库和缓存的更新操作是异步的，从而减少了延迟。

- 使用分布式锁：

当需要更新数据库和缓存时，先获取分布式锁。   
成功获取锁后，更新数据库和缓存。    
释放锁。    
这种策略可以确保在更新数据库和缓存时，只有一个操作能够成功。

- 监控和告警：

监控Redis缓存和数据库的数据一致性。    
如果发现数据不一致，立即触发告警，并尽快修复问题。

- 避免复杂查询：

尽量将复杂的查询逻辑放在数据库中，而不是在Redis缓存中进行。    
这样可以减少因缓存和数据库数据不一致而引发的错误。

- 考虑数据的时效性：

对于一些时效性较强的数据，可以考虑不放入Redis缓存，或者设置较短的缓存过期时间。    

需要注意的是，每种策略都有其优缺点，需要根据具体的应用场景和需求来选择最合适的策略。同时，确保Redis缓存和数据库数据的一致性是一个复杂的问题，需要综合考虑多个因素，并进行充分的测试和验证。