### MyISAM和InnoDB的区别
MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。
InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。
InnoDB支持外键，MyISAM不支持。
InnoDB的主键范围更大，最大是MyISAM的2倍。
InnoDB不支持全文索引，而MyISAM支持。全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。
没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。
InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
如何选择：
1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。
3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；
4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
### 索引结构（解释B+树）
   https://www.jb51.net/article/239235.htm
### 悲观锁和乐观锁
   悲观锁，是指在数据处理的过程中，保持比较保守的态度，占据要操作的数据权限，待操作结束后再稀放，由数据自身提供的锁机制来实现，根据锁的粒度，有表锁(table lock)、行锁(row lock)。由于表锁占用资源较大，通常我们多使用行锁（本次也是记录行锁）。
   具体悲观锁怎么实现？看mysql提供的select .... for update这种方式
   乐观锁，和悲观锁相反，认为在一般情况下，不会操作这种数据的冲突和数据的不一致，保存乐观的态度。然后大多通过编程方式实现，不依赖于数据库自身的锁机制。
   乐观锁的实现，不依赖数据库，通过我们代码逻辑的一种实现，比较普遍的做法就是通过版本控制。
### select执行过程
   1.连接器连接客户端，验证身份权限
   2.sql语句解析器，拆分sql语句，select from where，是否满足mysql的sql语句，语法错误返回报错
   3.sql优化器，先判断表权限，然后优化查询语句，选择使用哪个索引，多表join查询，优化表的连接顺序
   4.进入存储引擎查询结果，如果有索引，查询索引，没有遍历全表。索引判断是否是主键索引，是则查询主键索引（聚簇索引）返回结果，不是则查询普通索引，返回主键id，再根据主键id查询聚簇索引
### 事务隔离级别

MySQL的事务隔离级别主要有以下四种
   - READ UNCOMMITTED（读未提交）：
         最低的隔离级别，事务中的修改操作可以被其他事务读取，即一个事务可以读取到另一个事务尚未提交的数据。
     这种隔离级别可能导致脏读（Dirty Read）问题，即读取到未提交的数据。
   - READ COMMITTED（读已提交）：
         在该隔离级别下，事务只能读取到已经提交的数据。可以避免脏读，但是可能造成不可重复读、幻读。
   - REPEATABLE READ（可重复读）：
         对同一字段多次读取的结果都是一致的。
   - SERIALIZABLE（串行化）：
      最高的隔离级别，事务串行执行，确保了最高的数据一致性。但是并发性能极低，开发中很少用到。
### 索引回表
   聚簇索引：数据和索引一起的叫做聚簇索引
   非聚簇索引（二级索引/辅助索引）：数据和索引分开存储的叫做聚簇索引
   当查询非主键索引的到叶子节点的id主键时候，再到聚簇索引根据主键id查询数据就叫做回表
### 索引失效
   一般情况下的索引失效主要为索引占数据量大多数，mysql优化查找后不进行查询索引而是遍历全表
   不等号 != >< 导致索引失效
   is null使用索引，is not null 不使用索引
   like 以通配符 % 开头的索引失效
   or 前后存在非索引的列，都会导致索引失效
### 分库分表
   php直接引用mycat分表中间件，由于shardingJDBC不支持php，所以使用mycat，性能不及shardingJDBC
### 读写分离
   利用“mysql-proxy”+MGR集群模式实现读写分离；“mysql-proxy”是一个mysql官方提供用于实现读写分离的软件，也叫中间件，可以让主数据库处理写操作，而从数据库处理查询的操作，数据库的一致性则通过主从复制来实现。
   主节点发送binlog给从节点，从节点开启线程将binlog的内容读取到relaylog中，再异步执行
### PG和Mysql的区别
   pgsql查询效率是mysql的10倍左右，检索条件比较友好。
   PostgreSQL相对于MySQL的优势
   1、在SQL的标准实现上要比MySQL完善，而且功能实现比较严谨；
   2、存储过程的功能支持要比MySQL好，具备本地缓存执行计划的能力；
   3、对表连接支持较完整，优化器的功能较完整，支持的索引类型很多，复杂查询能力较强；
   4、PG主表采用堆表存放，MySQL采用索引组织表，能够支持比MySQL更大的数据量。
   5、PG的主备复制属于物理复制，相对于MySQL基于binlog的逻辑复制，数据的一致性更加可靠，复制性能更高，对主机性能的影响也更小。
   6、MySQL的存储引擎插件化机制，存在锁机制复杂影响并发的问题，而PG不存在。
### MySQL相对于PostgreSQL的优势
   1、innodb的基于回滚段实现的MVCC机制，相对PG新老数据一起存放的基于XID的MVCC机制，是占优的。新老数据一起存放，需要定时触 发VACUUM，会带来多余的IO和数据库对象加锁开销，引起数据库整体的并发能力下降。而且VACUUM清理不及时，还可能会引发数据膨胀；
   2、MySQL采用索引组织表，这种存储方式非常适合基于主键匹配的查询、删改操作，但是对表结构设计存在约束；
   3、MySQL的优化器较简单，系统表、运算符、数据类型的实现都很精简，非常适合简单的查询操作；
   4、MySQL分区表的实现要优于PG的基于继承表的分区实现，主要体现在分区个数达到上千上万后的处理性能差异较大。
   5、MySQL的存储引擎插件化机制，使得它的应用场景更加广泛，比如除了innodb适合事务处理场景外，myisam适合静态数据的查询场景。
   总结
   总的来说，开源数据库都不是很完善，商业数据库oracle在架构和功能方面都还是完善很多的。
   从应用场景来说，PG更加适合严格的企业应用场景（比如金融、电信、ERP、CRM），而MySQL更加适合业务逻辑相对简单、数据可靠性要求较低的互联网场景（比如google、facebook、alibaba）。
### explain用到那些信息
   1.id
   id 列，代表的是 select 语句执行的id，id 越大代表执行顺序越早，id 最小的最慢执行。
   2.select_type
   select_type 字段代表该 select 查询的类型，分为如下四种：
   SIMPLE：查询语句只有一个 select，没有其余子查询
   PRIMARY：复杂查询最前面的 select 查询，是最外层的查询
   SUBQUERY：from 关键字前的子查询
   DERIVED：from 关键字后的子查询，也叫派生查询
   UNION：在 union 查询中，第二个及其后面的 select 语句，都是 UNION类型
   3.table
   这一列表示 explain 的一行正在访问哪个表。
   4.type
   这一列表示关联类型或访问类型，即 MySQL 决定如何查找表中的行，查找数据行记录的大概范围。
   依次从最优到最差分别为：system > const > eq_ref > ref > range > index > ALL
   NULL：mysql 能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。
   const, system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system 是 const 的特例，表里只有一条元组匹配时为system。
   eq_ref：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。
   ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。
   range：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。
   index：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。
   ALL：即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。
   5.possible_key 列
   这一列显示查询可能使用哪些索引来查找。这只是可能用到的索引，最终是否真的使用了，还要看 key 列
   6.key 列
   这一列显示mysql实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 NULL。
   7.key_len 列
   这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。
   8.ref列
   这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）
9.rows列
   这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。
10.Extra列
    这一列展示的是额外信息。常见的重要值如下：
    1）Using index：使用覆盖索引
    覆盖索引定义：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。
    在这里插入图片描述
    2）Using where：使用 where 语句来处理结果，并且查询的列未被索引覆盖
    在这里插入图片描述
    3）Using index condition：查询的列不完全被索引覆盖，where条件中是一个前导列的范围；
    在这里插入图片描述
    4）Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索
    引来优化。
    actor.name没有索引，此时创建了张临时表来distinct
    在这里插入图片描述
    film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表
    在这里插入图片描述

5）Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一
般也是要考虑使用索引来优化的。
actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录
在这里插入图片描述
film.name建立了idx_name索引,此时查询时extra是using index
在这里插入图片描述

6）Select tables optimized away：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是

### 数据类型(int、char、varchar、datetime、text)分别的什么；

Int 整数char 定长字符 Varchar 变长字符 Datetime 日期时间型Text 文本型 Varchar与char的区别 char是固定长度的字符类型，分配多少空间，就占用多长空间。

### _varchar和char的区别

Varchar是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。由于varchar类型是可变的，所以在数据长度改变的时，服务器要进行额外的操作，所以效率比char类型低。

### 主键、外键和索引的区别

定义：主键--唯一标识一条记录，不能有重复的，不允许为空外键--表的外键是另一表的主键, 外键可以有重复的, 可以是空值索引--该字段没有重复值，但可以有一个空值
作用：主键--用来保证数据完整性外键--用来和其他表建立联系用的索引--是提高查询排序的速度
个数：主键--主键只能有一个外键--一个表可以有多个外键索引--一个表可以有多个唯一索引


### sql优化

SQL优化是一个涉及多个方面的过程，包括查询优化、索引优化、数据库设计优化等。以下是一些常见的SQL优化技巧和建议：

- 查询优化
   使用EXPLAIN分析查询：使用EXPLAIN命令来查看查询的执行计划，从而找出性能瓶颈。
   **避免SELECT ***：只选择需要的字段，而不是使用SELECT *。
   使用JOIN代替子查询：在可能的情况下，使用JOIN来代替子查询，这通常更高效。
   减少数据库调用：尽量减少对数据库的调用次数，比如使用批量插入或更新。
   避免在WHERE子句中使用函数：这可能导致索引失效。
- 索引优化
   创建适当的索引：为经常用于查询条件（WHERE、JOIN等）的字段创建索引。
   使用复合索引：对于多列的查询条件，考虑使用复合索引。
   避免过度索引：索引虽然可以提高查询速度，但也会降低插入、更新和删除的速度，因此需要权衡。
- 数据库设计优化
   规范化数据库设计：通过分解表来减少数据冗余。
   反规范化以提高性能：有时为了提高查询性能，可能需要增加一些冗余数据。
   使用合适的数据类型：为字段选择最合适的数据类型，避免使用过大的数据类型。
- 其他优化
   优化数据库配置：根据服务器的硬件和负载调整数据库的配置参数，如缓冲区大小、连接池大小等。
   定期维护数据库：使用如OPTIMIZE TABLE命令来整理表空间，定期清理无用数据。
   使用缓存：如Memcached或Redis等缓存系统，来缓存经常查询的数据。
   考虑使用分区：对于非常大的表，可以考虑使用分区来提高查询性能。
- 监控和分析
   使用监控工具：如Percona Monitoring and Management (PMM)、MySQL Enterprise Monitor等，来监控数据库的性能。
   分析慢查询日志：定期分析MySQL的慢查询日志，找出需要优化的查询。
   SQL优化是一个持续的过程，需要不断地监控、分析和调整。同时，也要考虑到具体的业务场景和需求，选择最合适的优化策略。


### 表设计 

MySQL表设计优化是数据库性能调优的重要部分，以下是一些关于MySQL表设计的优化建议：

- 规范化与反规范化

规范化（Normalization）：减少数据冗余，通过分解表来确保数据的一致性和完整性。
反规范化（Denormalization）：有时为了提高查询性能，可以故意增加一些冗余数据。例如，通过添加汇总表或计算字段来减少复杂查询的需要。

- 选择适当的数据类型

使用最适合字段需求的数据类型，以减少存储空间和提高性能。
避免使用不必要的大数据类型，例如，如果字段只存储年份，那么使用YEAR类型而不是INT。

- 使用索引

为经常用于搜索、排序和连接的字段创建索引。
考虑使用复合索引来覆盖多个查询条件。
避免在索引列上使用函数或表达式，这可能导致索引失效。

- 分区表

对于非常大的表，可以考虑使用分区来将表分成较小的、更易于管理的片段。
分区可以提高查询性能，并允许独立地备份和恢复表的各个部分。

- 使用合适的存储引擎

根据需求选择合适的存储引擎，如InnoDB或MyISAM。InnoDB支持事务和行级锁定，通常用于需要高并发写操作的场景。

- 垂直分割和水平分割

垂直分割：将表中的列分成两个或多个表，每个表包含部分列。这通常用于减少I/O操作，因为只读取需要的列。
水平分割：将表中的行分成两个或多个表，每个表包含部分行。这通常用于分散数据，减少单个表的大小。

- 优化BLOB和TEXT字段

尽量避免在表中频繁更新BLOB和TEXT字段，因为它们通常导致大量的I/O操作。
如果可能，考虑将这些字段移到单独的表中，并通过关系连接来访问它们。

- 避免NULL值

尽量避免在表中使用NULL值，因为它们可能导致查询效率下降，并增加索引的复杂性。
考虑使用默认值或额外的标志字段来代替NULL值。

- 使用缓存

利用MySQL的查询缓存（Query Cache）来缓存经常查询的结果集，提高查询速度。
在应用层使用外部缓存系统，如Redis或Memcached，来缓存计算结果或数据库访问结果。
- 优化表结构

移除不再需要的列和索引。
定期使用OPTIMIZE TABLE命令来整理表空间，回收未使用的空间。

- 监控和分析

使用MySQL的性能监控工具，如SHOW PROCESSLIST、SHOW INDEX等，来查看表的使用情况和性能瓶颈。
定期分析慢查询日志，找出需要优化的查询。
在设计数据库表时，需要根据具体的业务场景和需求进行权衡。优化表设计是一个持续的过程，需要不断地监控、分析和调整。
